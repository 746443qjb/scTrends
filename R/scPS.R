#' Automatic parameter selection for scTrends
#'
#' @description
#' `scPS()` performs automatic selection of core parameters used by
#' [scTrends()] based on a subset of genes taken from a binned
#' pseudotime dataset generated by [scBin()].
#'
#' The function:
#' \enumerate{
#'   \item Samples genes (optionally in a stratified manner).
#'   \item Optionally optimizes the GAM smoothness parameter `gam_k`
#'         using mean GCV across sampled genes.
#'   \item Extracts curve-shape and variability features from GAM fits
#'         (e.g. CV, range, prominence, slopes, monotonicity, residual variance).
#'   \item Derives data-driven thresholds for the trend classifier
#'         used in [scTrends()] (stable, monotone, peak-like, complex).
#'   \item Optionally visualizes diagnostic distributions and GAM fits.
#' }
#'
#' The resulting `optimal_params` list is designed to be passed directly
#' into [scTrends()] (e.g. via `do.call()`).
#'
#' @param scbin_result An object of class `"scBin"` produced by [scBin()].
#' @param test_genes Integer. Maximum number of genes to use for parameter
#'   optimization. When `sample_method != "none"`, this is the target
#'   number of sampled genes. Default: 500.
#' @param sample_method Character string specifying how to sample genes:
#'   \itemize{
#'     \item `"stratified"`: stratified sampling across CV tertiles.
#'     \item `"random"`: uniform random sampling.
#'     \item `"none"`: use all genes (no sampling).
#'   }
#' @param threshold_method Method used to derive feature thresholds.
#'   Currently `"quantile"` (data-driven) or `"default"` (fixed defaults).
#' @param optimize_gam_k Logical. If `TRUE`, search over a grid of `k`
#'   values (basis dimension for GAM smooth) and choose the value that
#'   minimizes mean GCV across sampled genes. If `FALSE`, use a heuristic
#'   `gam_k` based on the number of bins.
#' @param plot Logical. If `TRUE`, produce a multi-panel diagnostic
#'   plot summarizing parameter selection and feature distributions.
#' @param verbose Logical. If `TRUE`, print progress and summary messages.
#' @param return_features Logical. If `TRUE`, return raw feature vectors
#'   used for threshold derivation.
#'
#' @return
#' An object of class `"scPS"`, which is a list with components:
#' \describe{
#'   \item{optimal_params}{List of core parameters suitable for passing
#'         to [scTrends()] (e.g. `gam_k`, `stable_cv_threshold`,
#'         `min_peak_prominence`, `total_change_up`, etc.).}
#'   \item{feature_stats}{(Optional) List of feature vectors used during
#'         optimization, returned if `return_features = TRUE`.}
#'   \item{metadata}{List with metadata about the optimization procedure,
#'         such as number of genes tested, candidate `k` values and scores,
#'         sampling and threshold methods, and timestamp.}
#' }
#'
#' @examples
#' \dontrun{
#'   # sb <- scBin(seurat_obj, pseudotime_col = "pseudotime")
#'   ps <- scPS(sb, test_genes = 1000, sample_method = "stratified")
#'
#'   # Use optimal parameters in scTrends:
#'   trends <- do.call(
#'     scTrends,
#'     c(list(scbin_result = sb), ps$optimal_params)
#'   )
#' }
#'
#' @importFrom mgcv gam
#' @importFrom stats quantile sd median cor var lm coef predict
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom graphics par hist abline text legend barplot plot plot.new points lines mtext rect grid
#' @importFrom grDevices rgb
#' @export
scPS <- function(scbin_result,
                 test_genes = 500,
                 sample_method = "stratified",
                 threshold_method = "quantile",
                 optimize_gam_k = TRUE,
                 plot = TRUE,
                 verbose = TRUE,
                 return_features = FALSE) {

  if (!inherits(scbin_result, "scBin")) {
    stop("Input must be a scBin object produced by scBin().")
  }

  bin_means <- scbin_result$bin_means
  x         <- scbin_result$x
  n_genes_total <- nrow(bin_means)
  n_bins        <- ncol(bin_means)

  if (verbose) {
    cat("╔══════════════════════════════════════════════════════════╗\n")
    cat("║         scPS: Automatic Parameter Selection              ║\n")
    cat("║              (Core Parameter Optimization)               ║\n")
    cat("╚══════════════════════════════════════════════════════════╝\n\n")
    cat("  Dataset:          ", n_genes_total, "genes ×", n_bins, "bins\n")
    cat("  Sampling method:  ", sample_method, "\n")
    cat("  Threshold method: ", threshold_method, "\n\n")
  }

  # ============================================================
  # Phase 1: gene sampling
  # ============================================================
  if (sample_method == "none") {
    sampled_genes <- rownames(bin_means)
    n_test <- n_genes_total
    if (verbose) cat("  Using ALL", n_genes_total, "genes (no sampling)\n\n")

  } else {
    n_test <- min(test_genes, n_genes_total)

    if (sample_method == "stratified") {
      gene_cv <- apply(bin_means, 1, function(y) {
        stats::sd(y, na.rm = TRUE) / abs(mean(y, na.rm = TRUE))
      })
      gene_cv[is.nan(gene_cv) | is.infinite(gene_cv)] <- 0

      q <- stats::quantile(gene_cv, c(0.33, 0.67), na.rm = TRUE)
      sampled_genes <- c(
        sample(names(gene_cv)[gene_cv <= q[1]],
               min(n_test %/% 3, sum(gene_cv <= q[1]))),
        sample(names(gene_cv)[gene_cv > q[1] & gene_cv <= q[2]],
               min(n_test %/% 3, sum(gene_cv > q[1] & gene_cv <= q[2]))),
        sample(names(gene_cv)[gene_cv > q[2]],
               n_test - 2 * (n_test %/% 3))
      )
    } else if (sample_method == "random") {
      sampled_genes <- sample(rownames(bin_means), n_test)
    } else {
      stop("Invalid sample_method. Choose 'stratified', 'random', or 'none'.")
    }

    if (verbose) cat("  Sampled", length(sampled_genes), "genes\n\n")
  }

  # ============================================================
  # Phase 2: optimize gam_k
  # ============================================================
  if (optimize_gam_k) {
    if (verbose) {
      cat("Optimizing gam_k parameter (testing on",
          length(sampled_genes), "genes)...\n")
    }

    k_min <- 3
    k_max <- min(8, n_bins - 2)

    if (k_max <= k_min) {
      gam_k_optimal <- k_min
      if (verbose) cat("  Warning: too few bins, using k =", gam_k_optimal, "\n\n")
      k_candidates <- k_min
      k_scores <- NA_real_
    } else {
      k_candidates <- seq(k_min, k_max, by = 1)
      n_k          <- length(k_candidates)
      n_genes_test <- length(sampled_genes)

      if (verbose) {
        cat("  Testing", n_k, "k values on", n_genes_test, "genes...\n")
        pb_total <- utils::txtProgressBar(
          min = 0, max = n_k * n_genes_test,
          style = 3, char = "="
        )
        progress_counter <- 0
      }

      k_scores <- sapply(k_candidates, function(k_test) {
        gcv_values <- sapply(sampled_genes, function(gene) {
          if (verbose) {
            progress_counter <<- progress_counter + 1
            utils::setTxtProgressBar(pb_total, progress_counter)
          }

          gm <- bin_means[gene, ]
          ok <- !is.na(gm) & !is.na(x)
          if (sum(ok) < 4) return(NA_real_)

          gm <- gm[ok]
          x2 <- x[ok]

          fit <- tryCatch({
            mgcv::gam(
              y ~ s(x, k = min(k_test, length(x2) - 2)),
              data   = data.frame(y = gm, x = x2),
              method = "GCV.Cp"
            )
          }, error = function(e) NULL)

          if (is.null(fit)) return(NA_real_)
          fit$gcv.ubre
        })
        mean(gcv_values, na.rm = TRUE)
      })

      if (verbose) {
        close(pb_total)
        cat("\n")
      }

      best_k_idx   <- which.min(k_scores)
      gam_k_optimal <- k_candidates[best_k_idx]
      if (is.na(gam_k_optimal)) gam_k_optimal <- 5

      if (verbose) {
        cat("  • k candidates: ", paste(k_candidates, collapse = ", "), "\n", sep = "")
        cat("  • GCV scores:   ",
            paste(round(k_scores, 4), collapse = ", "), "\n", sep = "")
        cat("  ✓ Optimal k = ", gam_k_optimal, "\n\n", sep = "")
      }
    }
  } else {
    gam_k_optimal <- max(3, min(ceiling(sqrt(n_bins)), 8))
    if (verbose) cat("Using heuristic gam_k =", gam_k_optimal, "\n\n")
    k_candidates <- gam_k_optimal
    k_scores     <- NA_real_
  }

  # ============================================================
  # Phase 3: feature extraction
  # ============================================================
  calc_slope <- function(y, xv) {
    if (length(y) < 2) return(NA_real_)
    tryCatch(stats::coef(stats::lm(y ~ xv))[2], error = function(e) NA_real_)
  }

  if (verbose) {
    cat("Extracting features from", length(sampled_genes), "genes...\n")
  }
  pb <- utils::txtProgressBar(min = 0, max = length(sampled_genes), style = 3)

  features_list <- lapply(seq_along(sampled_genes), function(i) {
    utils::setTxtProgressBar(pb, i)

    gm <- bin_means[sampled_genes[i], ]
    ok <- !is.na(gm) & !is.na(x)
    if (sum(ok) < 4) return(NULL)

    gm <- gm[ok]
    x2 <- x[ok]
    n  <- length(gm)

    cv       <- stats::sd(gm) / abs(mean(gm))
    rel_chg  <- (max(gm) - min(gm)) / stats::median(gm)
    autocorr <- if (n >= 3) {
      tryCatch(stats::cor(gm[-n], gm[-1], method = "spearman"),
               error = function(e) NA_real_)
    } else NA_real_

    fit <- tryCatch({
      mgcv::gam(y ~ s(x, k = min(gam_k_optimal, n - 2)),
                data = data.frame(y = gm, x = x2))
    }, error = function(e) NULL)

    if (is.null(fit)) return(NULL)

    pred <- stats::predict(fit)
    rng  <- max(pred) - min(pred)
    if (rng < 1e-6) rng <- 1e-6

    peak_idx   <- which.max(pred)
    valley_idx <- which.min(pred)

    peak_prom   <- (max(pred) - max(pred[1], pred[n])) / rng
    valley_prom <- (min(pred[1], pred[n]) - min(pred)) / rng

    left_slope <- if (peak_idx > 1 && peak_idx < n) {
      calc_slope(pred[1:peak_idx], x2[1:peak_idx]) / rng
    } else NA_real_

    right_slope <- if (peak_idx > 1 && peak_idx < n) {
      calc_slope(pred[peak_idx:n], x2[peak_idx:n]) / rng
    } else NA_real_

    total_chg_signed <- (pred[n] - pred[1]) / rng
    diffs      <- diff(pred)
    mono_score <- max(mean(diffs > 0), mean(diffs < 0))
    sign_chg   <- sum(abs(diff(sign(diffs))) == 2, na.rm = TRUE)
    resid_var  <- stats::var(gm - pred) / stats::var(gm)

    list(
      cv                  = cv,
      relative_change     = rel_chg,
      autocorr            = autocorr,
      peak_prominence     = peak_prom,
      valley_prominence   = valley_prom,
      left_slope_norm     = abs(left_slope),
      right_slope_norm    = abs(right_slope),
      total_change_signed = total_chg_signed,
      total_change        = abs(total_chg_signed),
      monotone_score      = mono_score,
      sign_changes        = sign_chg,
      residual_variance   = resid_var
    )
  })
  close(pb)

  features_list <- features_list[!sapply(features_list, is.null)]
  if (verbose) {
    cat("  ✓ Extracted", length(features_list), "feature sets\n\n")
  }

  # ============================================================
  # Phase 3.5: representative GAM fits for plotting
  # ============================================================
  if (plot && length(features_list) >= 3) {
    resid_vars <- sapply(features_list, function(f) f$residual_variance)
    sorted_idx <- order(resid_vars)
    n_fg       <- length(resid_vars)

    example_indices <- c(
      sorted_idx[round(n_fg * 0.1)],
      sorted_idx[round(n_fg * 0.5)],
      sorted_idx[round(n_fg * 0.9)]
    )

    example_fits <- lapply(example_indices, function(idx) {
      gm <- bin_means[sampled_genes[idx], ]
      ok <- !is.na(gm) & !is.na(x)
      if (sum(ok) < 4) return(NULL)

      gm <- gm[ok]
      x2 <- x[ok]

      fit <- tryCatch({
        mgcv::gam(y ~ s(x, k = min(gam_k_optimal, length(x2) - 2)),
                  data = data.frame(y = gm, x = x2))
      }, error = function(e) NULL)

      if (is.null(fit)) return(NULL)

      pred <- stats::predict(fit)

      # Normalize to [0, 1]
      gm_norm   <- (gm   - min(gm))   / (max(gm)   - min(gm)  )
      pred_norm <- (pred - min(pred)) / (max(pred) - min(pred))

      list(
        x        = x2,
        observed = gm_norm,
        fitted   = pred_norm,
        resid_var = features_list[[idx]]$residual_variance
      )
    })

    example_fits <- example_fits[!sapply(example_fits, is.null)]
  } else {
    example_fits <- NULL
  }

  # ============================================================
  # Phase 4: derive thresholds
  # ============================================================
  if (verbose) cat("Computing optimal thresholds...\n")

  extract <- function(name) {
    vals <- sapply(features_list, function(f) f[[name]])
    vals[!is.na(vals) & !is.infinite(vals)]
  }

  all_cv        <- extract("cv")
  all_rel_chg   <- extract("relative_change")
  all_autocorr  <- extract("autocorr")
  all_peak_prom <- extract("peak_prominence")
  all_valley_prom <- extract("valley_prominence")
  all_left_slope  <- extract("left_slope_norm")
  all_right_slope <- extract("right_slope_norm")
  all_total_chg_signed <- extract("total_change_signed")
  all_total_chg        <- extract("total_change")
  all_mono_score <- extract("monotone_score")
  all_sign_chg   <- extract("sign_changes")
  all_resid_var  <- extract("residual_variance")

  up_changes   <- all_total_chg_signed[all_total_chg_signed > 0]
  down_changes <- all_total_chg_signed[all_total_chg_signed < 0]

  if (threshold_method == "quantile") {
    # Stable parameters
    low_cv_genes    <- all_cv       < stats::quantile(all_cv,       0.20, na.rm = TRUE)
    low_range_genes <- all_rel_chg  < stats::quantile(all_rel_chg,  0.20, na.rm = TRUE)
    candidate_stable <- low_cv_genes & low_range_genes
    n_stable_candidates <- sum(candidate_stable, na.rm = TRUE)

    if (n_stable_candidates >= 20) {
      stable_cv    <- stats::quantile(all_cv[candidate_stable],      0.95, na.rm = TRUE)
      stable_range <- stats::quantile(all_rel_chg[candidate_stable], 0.95, na.rm = TRUE)
      if (is.na(stable_cv)    || stable_cv    > 0.30) stable_cv    <- 0.12
      if (is.na(stable_range) || stable_range > 0.30) stable_range <- 0.10
      if (verbose) cat("  • Found", n_stable_candidates, "stable candidates\n")
    } else {
      if (verbose) cat("  Warning: too few stable candidates, using defaults\n")
      stable_cv    <- 0.12
      stable_range <- 0.10
    }

    high_autocorr_genes <- all_autocorr > stats::quantile(all_autocorr, 0.70, na.rm = TRUE)
    if (sum(high_autocorr_genes, na.rm = TRUE) >= 20) {
      stable_autocorr <- stats::quantile(
        all_autocorr[high_autocorr_genes], 0.10, na.rm = TRUE
      )
      if (is.na(stable_autocorr) || stable_autocorr < 0.50) stable_autocorr <- 0.75
      if (stable_autocorr > 0.95) stable_autocorr <- 0.85
    } else {
      stable_autocorr <- 0.80
    }

    # Peak / valley parameters
    all_prom <- c(all_peak_prom, all_valley_prom)
    all_prom <- all_prom[all_prom > 0.05]
    high_prom_genes <- all_prom > stats::median(all_prom, na.rm = TRUE)
    if (sum(high_prom_genes, na.rm = TRUE) >= 20) {
      min_peak_prom <- stats::quantile(all_prom[high_prom_genes], 0.20, na.rm = TRUE)
      if (is.na(min_peak_prom) || min_peak_prom < 0.08) min_peak_prom <- 0.12
      if (min_peak_prom > 0.40) min_peak_prom <- 0.20
    } else {
      min_peak_prom <- 0.15
    }

    all_slopes <- c(all_left_slope, all_right_slope)
    all_slopes <- all_slopes[all_slopes > 0.01]
    high_slope_genes <- all_slopes > stats::median(all_slopes, na.rm = TRUE)
    if (sum(high_slope_genes, na.rm = TRUE) >= 20) {
      min_slope <- stats::quantile(all_slopes[high_slope_genes], 0.15, na.rm = TRUE)
      if (is.na(min_slope) || min_slope < 0.03) min_slope <- 0.06
      if (min_slope > 0.20) min_slope <- 0.10
    } else {
      min_slope <- 0.08
    }

    # Monotone parameters
    total_chg_up   <- stats::quantile(up_changes,   0.30, na.rm = TRUE)
    total_chg_down <- stats::quantile(down_changes, 0.70, na.rm = TRUE)
    if (is.na(total_chg_up)   || total_chg_up   <  0.08) total_chg_up   <-  0.12
    if (is.na(total_chg_down) || total_chg_down > -0.08) total_chg_down <- -0.12

    mono_cons <- stats::quantile(all_mono_score, 0.65, na.rm = TRUE)
    if (is.na(mono_cons) || mono_cons < 0.55) mono_cons <- 0.65
    if (mono_cons > 0.85) mono_cons <- 0.75

    # Complex parameters
    min_sign_chg_complex <- max(
      3,
      ceiling(stats::quantile(all_sign_chg[all_sign_chg > 0], 0.75, na.rm = TRUE))
    )
    complex_var <- stats::quantile(all_resid_var, 0.60, na.rm = TRUE)
    if (is.na(complex_var) || complex_var < 0.15) complex_var <- 0.25
    if (complex_var > 0.50) complex_var <- 0.35

  } else {
    # fallback defaults
    stable_cv          <- 0.12
    stable_range       <- 0.10
    stable_autocorr    <- 0.80
    min_peak_prom      <- 0.15
    min_slope          <- 0.08
    total_chg_up       <- 0.15
    total_chg_down     <- -0.15
    mono_cons          <- 0.70
    min_sign_chg_complex <- 3
    complex_var        <- 0.30
  }

  optimal_params <- list(
    min_cells                = 4,
    gam_k                    = gam_k_optimal,
    peak_position_margin     = 0.15,
    max_sign_changes_mono    = 1,
    stable_cv_threshold      = unname(stable_cv),
    stable_range_threshold   = unname(stable_range),
    stable_autocorr_threshold = unname(stable_autocorr),
    min_peak_prominence      = unname(min_peak_prom),
    min_slope_ratio          = unname(min_slope),
    total_change_up          = unname(total_chg_up),
    total_change_down        = unname(total_chg_down),
    monotone_consistency     = unname(mono_cons),
    min_sign_changes_complex = unname(min_sign_chg_complex),
    complex_variance_threshold = unname(complex_var),
    compute_pvalue           = FALSE,
    n_perm                   = 0
  )

  if (verbose) {
    cat("\n╔══════════════════════════════════════════════════════════╗\n")
    cat("║                     Optimal Parameters                   ║\n")
    cat("╚══════════════════════════════════════════════════════════╝\n\n")
    cat("Fixed parameters:\n")
    cat(sprintf("  • min_cells:            %d\n", 4))
    cat(sprintf("  • peak_position_margin: %.2f\n", 0.15))
    cat(sprintf("  • max_sign_changes:     %d\n\n", 1))

    cat("GAM smoothing:\n")
    cat(sprintf("  • gam_k:                %d\n\n", gam_k_optimal))

    cat("Stable detection:\n")
    cat(sprintf("  • CV threshold:         %.3f\n", stable_cv))
    cat(sprintf("  • Range threshold:      %.3f\n", stable_range))
    cat(sprintf("  • Autocorr threshold:   %.3f\n\n", stable_autocorr))

    cat("Peak/valley detection:\n")
    cat(sprintf("  • Min prominence:       %.3f\n", min_peak_prom))
    cat(sprintf("  • Min slope:            %.3f\n\n", min_slope))

    cat("Monotone detection:\n")
    cat(sprintf("  • Up threshold:         %.3f\n", total_chg_up))
    cat(sprintf("  • Down threshold:       %.3f\n", total_chg_down))
    cat(sprintf("  • Consistency:          %.3f\n\n", mono_cons))

    cat("Complex detection:\n")
    cat(sprintf("  • Min sign changes:     %d\n",   min_sign_chg_complex))
    cat(sprintf("  • Variance threshold:   %.3f\n\n", complex_var))

    cat("Tested on", length(features_list), "genes\n\n")
  }

  # Data passed to plotting function
  plot_data <- list(
    k_candidates    = k_candidates,
    k_scores        = k_scores,
    gam_k_optimal   = gam_k_optimal,
    all_cv          = all_cv,
    all_rel_chg     = all_rel_chg,
    all_autocorr    = all_autocorr,
    all_prom        = c(all_peak_prom, all_valley_prom),
    all_slopes      = c(all_left_slope, all_right_slope),
    all_total_chg_signed = all_total_chg_signed,
    all_mono_score  = all_mono_score,
    all_sign_chg    = all_sign_chg,
    all_resid_var   = all_resid_var,
    stable_cv       = stable_cv,
    stable_range    = stable_range,
    stable_autocorr = stable_autocorr,
    min_peak_prom   = min_peak_prom,
    min_slope       = min_slope,
    total_chg_up    = total_chg_up,
    total_chg_down  = total_chg_down,
    mono_cons       = mono_cons,
    min_sign_chg_complex = min_sign_chg_complex,
    complex_var     = complex_var,
    n_genes_tested  = length(features_list),
    example_fits    = example_fits
  )

  if (plot) {
    plot_scPS_diagnostics(plot_data)
  }

  # Return object
  output <- list(
    optimal_params = optimal_params,
    feature_stats = if (return_features) {
      list(
        cv               = all_cv,
        relative_change  = all_rel_chg,
        autocorr         = all_autocorr,
        peak_prominence  = all_peak_prom,
        valley_prominence = all_valley_prom,
        left_slope       = all_left_slope,
        right_slope      = all_right_slope,
        all_prominence   = c(all_peak_prom, all_valley_prom),
        all_slopes       = c(all_left_slope, all_right_slope),
        up_changes       = up_changes,
        down_changes     = down_changes,
        monotone_score   = all_mono_score,
        sign_changes     = all_sign_chg,
        residual_variance = all_resid_var
      )
    } else NULL,
    metadata = list(
      n_genes_total     = n_genes_total,
      n_genes_tested    = length(features_list),
      n_stable_candidates = if (exists("n_stable_candidates")) n_stable_candidates else NA,
      gam_k_optimal     = gam_k_optimal,
      gam_k_test_genes  = length(sampled_genes),
      gam_k_candidates  = k_candidates,
      gam_k_scores      = k_scores,
      sample_method     = sample_method,
      threshold_method  = threshold_method,
      timestamp         = Sys.time()
    )
  )

  class(output) <- "scPS"
  return(output)
}
#' Diagnostic plots for scPS
#'
#' @description
#' Internal helper that creates a 3×4 grid of diagnostic plots summarizing
#' the parameter selection process in [scPS()]: GAM k optimization,
#' distributions of CV, range, autocorrelation, prominence, slopes,
#' monotone scores, sign changes, residual variance, symmetry, and
#' example GAM fits.
#'
#' @param plot_data A named list created inside [scPS()] containing
#'   feature vectors, selected thresholds, and optional example fits.
#'
#' @keywords internal
#' @noRd
plot_scPS_diagnostics <- function(plot_data) {
  graphics::par(
    mfrow = c(4, 3),          # 4行3列（每行3张图）
    mar   = c(4.5, 4.5, 3.5, 1.2),
    oma   = c(0, 0, 4, 0)
  )

  # ===== Panel 1: GAM k optimization =====
  if (!all(is.na(plot_data$k_scores))) {
    graphics::plot(
      plot_data$k_candidates, plot_data$k_scores,
      type = "b", pch = 19,
      xlab = "k value", ylab = "Mean GCV",
      main = "GAM k Optimization", las = 1, lwd = 2
    )

    k_opt <- plot_data$gam_k_optimal
    idx_opt <- which(plot_data$k_candidates == k_opt)
    graphics::points(
      k_opt, plot_data$k_scores[idx_opt],
      pch = 21, cex = 2.5, col = "#E63946", bg = "#FFB4A2", lwd = 2
    )
    graphics::abline(v = k_opt, col = "#E63946", lty = 2, lwd = 2)
    graphics::text(
      k_opt,
      max(plot_data$k_scores, na.rm = TRUE) * 0.95,
      paste0("k = ", k_opt),
      pos = 4, col = "#E63946", font = 2
    )
    graphics::grid(col = "gray90", lty = 3)
  } else {
    graphics::plot.new()
    graphics::text(0.5, 0.5, "k not optimized", cex = 1.2, col = "gray50")
  }

  # ===== Panel 2: CV distribution =====
  graphics::hist(
    plot_data$all_cv, breaks = 50,
    col = "#C1D7AE", border = "white",
    xlab = "Coefficient of Variation", main = "Stable: CV Threshold", las = 1
  )
  graphics::abline(v = plot_data$stable_cv, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 3: Relative range distribution =====
  graphics::hist(
    plot_data$all_rel_chg, breaks = 50,
    col = "#FFB4A2", border = "white",
    xlab = "Relative Range", main = "Stable: Range Threshold", las = 1,
    xlim = c(0, stats::quantile(plot_data$all_rel_chg, 0.99, na.rm = TRUE))
  )
  graphics::abline(v = plot_data$stable_range, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 4: Autocorrelation distribution =====
  graphics::hist(
    plot_data$all_autocorr, breaks = 30,
    col = "#B5E48C", border = "white",
    xlab = "Spearman Autocorrelation", main = "Stable: Autocorr Threshold",
    las = 1
  )
  graphics::abline(v = plot_data$stable_autocorr, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 5: Peak/valley prominence =====
  graphics::hist(
    plot_data$all_prom, breaks = 40,
    col = "#FFC6FF", border = "white",
    xlab = "Peak/Valley Prominence", main = "Peak: Prominence Threshold",
    las = 1,
    xlim = c(0, stats::quantile(plot_data$all_prom, 0.95, na.rm = TRUE))
  )
  graphics::abline(v = plot_data$min_peak_prom, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 6: Normalized slopes =====
  graphics::hist(
    plot_data$all_slopes, breaks = 40,
    col = "#CAFFBF", border = "white",
    xlab = "Normalized Slope", main = "Peak: Slope Threshold",
    las = 1,
    xlim = c(0, stats::quantile(plot_data$all_slopes, 0.95, na.rm = TRUE))
  )
  graphics::abline(v = plot_data$min_slope, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 7: Signed total change =====
  graphics::hist(
    plot_data$all_total_chg_signed, breaks = 50,
    col = "#A0C4FF", border = "white",
    xlab = "Signed Total Change", main = "Monotone: Total Change", las = 1
  )
  graphics::abline(v = plot_data$total_chg_up,   col = "#06A77D", lwd = 2.5, lty = 2)
  graphics::abline(v = plot_data$total_chg_down, col = "#D62828", lwd = 2.5, lty = 2)
  graphics::legend(
    "topright",
    legend = c(
      sprintf("Up: %.3f", plot_data$total_chg_up),
      sprintf("Down: %.3f", plot_data$total_chg_down)
    ),
    col = c("#06A77D", "#D62828"), lwd = 2, bty = "n", cex = 0.8
  )

  # ===== Panel 8: Monotone score =====
  graphics::hist(
    plot_data$all_mono_score, breaks = 30,
    col = "#BDB2FF", border = "white",
    xlab = "Monotone Consistency", main = "Monotone: Consistency Threshold",
    las = 1
  )
  graphics::abline(v = plot_data$mono_cons, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 9: Number of sign changes =====
  graphics::hist(
    plot_data$all_sign_chg,
    breaks = max(plot_data$all_sign_chg, na.rm = TRUE),
    col = "#FFD6A5", border = "white",
    xlab = "Number of Sign Changes", main = "Complex: Sign Changes Threshold",
    las = 1
  )
  graphics::abline(v = plot_data$min_sign_chg_complex, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 10: Residual variance =====
  graphics::hist(
    plot_data$all_resid_var, breaks = 40,
    col = "#FDFFB6", border = "white",
    xlab = "Residual Variance Ratio", main = "Complex: Variance Threshold",
    las = 1,
    xlim = c(0, stats::quantile(plot_data$all_resid_var, 0.95, na.rm = TRUE))
  )
  graphics::abline(v = plot_data$complex_var, col = "#E63946", lwd = 2.5, lty = 2)

  # ===== Panel 11: Up/Down symmetry =====
  asymmetry_ratio <- abs(plot_data$total_chg_up / plot_data$total_chg_down)
  graphics::barplot(
    c(Up = plot_data$total_chg_up, Down = abs(plot_data$total_chg_down)),
    col = c("#06A77D", "#D62828"), border = "white",
    main = "Up/Down Symmetry Check", las = 1,
    ylab = "Absolute Threshold"
  )
  graphics::text(
    1.5,
    max(plot_data$total_chg_up, abs(plot_data$total_chg_down)) * 1.1,
    paste0("Ratio = ", round(asymmetry_ratio, 2)),
    col = "black", font = 2
  )

  # ===== Panel 12: GAM fitting quality examples =====
  if (!is.null(plot_data$example_fits)) {
    graphics::plot(
      NULL, xlim = c(0, 1), ylim = c(-0.1, 1.1),
      xlab = "Pseudotime", ylab = "Normalized Expression",
      main = "GAM Fitting Quality Examples", las = 1
    )

    colors <- c("#06A77D", "#FFA500", "#E63946")
    labels <- c("Good Fit (Low Var)", "Medium Fit", "Poor Fit (High Var)")

    for (i in seq_len(min(3, length(plot_data$example_fits)))) {
      fit_data <- plot_data$example_fits[[i]]
      graphics::lines(fit_data$x, fit_data$fitted, col = colors[i], lwd = 2.5)
      graphics::points(fit_data$x, fit_data$observed,
                       col = colors[i], pch = 16, cex = 0.7)
    }

    graphics::legend("topright", legend = labels, col = colors,
                     lwd = 2.5, bty = "n", cex = 0.8)
    graphics::grid(col = "gray90", lty = 3)
  } else {
    graphics::plot(
      plot_data$all_resid_var,
      1 - plot_data$all_resid_var,
      pch = 16,
      col = grDevices::rgb(0.2, 0.4, 0.7, 0.3),
      xlab = "Residual Variance",
      ylab = "Fitting Quality (1 - Var)",
      main = "GAM Fitting Quality", las = 1
    )
    graphics::abline(h = 1 - plot_data$complex_var,
                     col = "#E63946", lty = 2, lwd = 2)
    graphics::grid(col = "gray90", lty = 3)
  }

  graphics::mtext(
    "scPS: Parameter Selection Diagnostics",
    outer = TRUE, cex = 1.3, font = 2, line = 0.5
  )

  graphics::par(mfrow = c(1, 1))
}

